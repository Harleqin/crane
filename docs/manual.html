<h1 id="overview">Overview</h1>
<p>Crane is an ORM for Common Lisp. It's intended to provide a simple, object-oriented interface to relational databases, inspired by the simplicity of the Django ORM and the flexible, non-opinionated philosophy of SQLAlchemy.</p>
<h2 id="structure">Structure</h2>
<p>Crane mainly uses two libraries:</p>
<dl>
<dt><a href="https://github.com/fukamachi/sxql">sxql</a></dt>
<dd>A DSL for generating SQL through function composition.
</dd>
<dt><a href="https://github.com/fukamachi/cl-dbi">cl-dbi</a></dt>
<dd>A backend-independent interface to relational DBMSs. At present, only PostgreSQL, SQLite version 3, and MySQL are supported, but support for Oracle and MS SQL Server can be added.
</dd>
</dl>
<h1 id="connecting">Connecting</h1>
<p>Crane autoconnects to all the databases specified in the <code>:databases</code> key of the configuration when the <code>crane:connect</code> function is called (No parameters).</p>
<p>Configuration for the databases might look like this:</p>
<pre class="lisp"><code>(crane:setup
 `(:migrations-directory
   ,(merge-pathnames
     #p&quot;t/migrations/&quot;
     (asdf:component-pathname (asdf:find-system :crane-test)))
   :databases
   (:main
    (:type :postgres
     :name &quot;crane_test_db&quot;
     :user &quot;crane_test_user&quot;
     :pass &quot;crane_test_user&quot;)
    :interface
    (:type :sqlite3
     :name &quot;:memory:&quot;))))</code></pre>
<p>The value of <code>:databases</code> is a plist that maps a database's name (Not that actual name, but rather a way to identify it, like <code>:main</code> or <code>:users-db</code>) to a list of connection parameters, called the <em>connection spec</em>.</p>
<p>Crane maintains a list of connection specs for every supported database backend, and ensures that all required parameters and no parameters other than the required and optional ones are passed. Connection specs for all supported backends are listed in <a href="#appendix-a-connecting">Appendix A: Connecting</a>.</p>
<h1 id="tables">Tables</h1>
<p>Crane uses the metaobject protocol to bind SQL tables and CLOS objects through a <code>TABLE-CLASS</code> metaclass. Table classes can be defined simply through the <code>deftable</code> macro:</p>
<pre class="lisp"><code>(deftable &lt;name&gt; (&lt;superclass&gt;*)
  &lt;field-or-option&gt;*)</code></pre>
<p>Compare the following code to the previous example:</p>
<pre class="lisp"><code>(deftable enemy ()
  (name :type string :pk t)
  (age :type integer :check &#39;(:&gt; &#39;age 12))
  (address :type &#39;string :nullp t :foreign (important-addresses :cascade :cascade))
  (fatal-weakness :type text :default &quot;None&quot;)
  (identifying-color &#39;type (string 20) :unique t :foreign (colors name)))</code></pre>
<h1 id="creating-saving-and-deleting-objects">Creating, Saving, and Deleting Objects</h1>
<h2 id="create"><code>create</code></h2>
<dl>
<dt>Syntax:</dt>
<dd><code>(create &lt;class&gt; &lt;params&gt;*)</code>
</dd>
</dl>
<p>Create an instance of a class on the database.</p>
<p><strong>Examples:</strong></p>
<pre class="lisp"><code>(create &#39;user :name &quot;Eudoxia&quot;)

(create &#39;company :name &quot;Initech&quot; :founded 1994)</code></pre>
<h2 id="save"><code>save</code></h2>
<dl>
<dt>Syntax:</dt>
<dd><code>(save &lt;instance&gt;)</code>
</dd>
</dl>
<p>Save an instance's fields to the database.</p>
<p><strong>Examples:</strong></p>
<pre class="lisp"><code>(let ((point (create &#39;point :x 556.3 :y 26.7)))
  ;; Make some changes
  (setf (point-distance-from-origin point)
        (euclidean-distance point &#39;(0 0)))
  ;; Save
  (save point))</code></pre>
<h2 id="del"><code>del</code></h2>
<dl>
<dt>Syntax:</dt>
<dd><code>(del &lt;instance&gt;)</code>
</dd>
</dl>
<p>Delete an instance from the database.</p>
<p><strong>Examples:</strong></p>
<pre class="lisp"><code>(defun delete-user (username)
  (del (single &#39;user :name username)))</code></pre>
<h1 id="making-queries">Making Queries</h1>
<h2 id="high-level-api">High Level API</h2>
<h3 id="filter"><code>filter</code></h3>
<dl>
<dt>Syntax:</dt>
<dd><code>(filter &lt;class&gt; &lt;params&gt;*)</code>
</dd>
</dl>
<p>Return a list of objects that satisfy the <code>params</code>.</p>
<p><strong>Examples:</strong></p>
<pre class="lisp"><code>  (filter &#39;company :country &quot;US&quot;
                   (:&lt; nemployees 40))</code></pre>
<h3 id="single"><code>single</code></h3>
<dl>
<dt>Syntax:</dt>
<dd><code>(filter &lt;class&gt; &lt;params&gt;*)</code>
</dd>
</dl>
<p>Return a single object that satisfies the parameters.</p>
<p>A variant, <code>single!</code>, will signal a condition when no object satisfies the parameters.</p>
<h3 id="get-or-create"><code>get-or-create</code></h3>
<h2 id="functional-sql">Functional SQL</h2>
<h1 id="migrations">Migrations</h1>
<p>Your schema will change, and this is a fact. Most ORMs hope the users will be happy running manual <code>ALTER TABLEs</code> or provide migration functionality through an external plugin (<a href="https://alembic.readthedocs.org/en/latest/front.html">Alembic</a> for SQLAlchemy, <a href="http://south.aeracode.org/">South</a> for the Django ORM).</p>
<p>Migrations are completely built into Crane, and are designed to be intrusive: You redefine the schema, reload, and Crane takes care of everything. If your migration plan is too complicated for Crane, then you write a simple function that does some transformations and Crane puts that in its migration history, all that without ever having to leave your Lisp environment or accessing the shell.</p>
<h2 id="example">Example</h2>
<pre class="lisp"><code>(deftable employees
  (name :type string :null nil)
  (age  :type integer)
  (address :type string :null nil))</code></pre>
<p>Now, if you decide that addresses can be nullable, you just redefine the class (Make the change, and either <code>C-c C-c</code> on Emacs or Quickload your project):</p>
<pre class="lisp"><code>(deftable employees
  (name :type string :null nil)
  (age  :type integer)
  (address :type string))</code></pre>
<p>And Crane will spot the difference and perform the migration automatically.</p>
<h2 id="trivial-migrations">Trivial Migrations</h2>
<p>Things like adding and dropping contraints (Making a field <code>NOT NULLable</code>, dropping the default value of a column, et cetera) will be handled automatically by Crane.</p>
<p>A less-than-trivial migration is changing the type of a column: In simple cases, like moving from a float to an integer, Crane will handle this change automatically.</p>
<h1 id="transactions">Transactions</h1>
<p>Crane supports a thin wrapper over CL-DBI's transaction capabilities.</p>
<h2 id="with-transaction"><code>with-transaction</code></h2>
<dl>
<dt>Syntax:</dt>
<dd><code>(with-transaction ([db-name *default-db*]) &lt;body&gt;*)</code>
</dd>
</dl>
<p>Execute <code>body</code> inside a transaction. If the code executes, the transaction is comitted. If a condition is signalled, the transaction is rolled back.</p>
<p><strong>Examples:</strong></p>
<pre><code>  (with-transaction (:my-db)
    (let ((restaurants (filter &#39;&lt;restaurant&gt; ...)))
        (loop for restaurant in restaurants do
            ...
            (save restaurant))))</code></pre>
<h2 id="begin-transaction"><code>begin-transaction</code></h2>
<dl>
<dt>Syntax:</dt>
<dd><code>(begin-transaction [db-name *default-db*])</code>
</dd>
</dl>
<p>Start a transaction on the database <code>db-name</code>.</p>
<h2 id="commit"><code>commit</code></h2>
<dl>
<dt>Syntax:</dt>
<dd><code>(commit [db-name *default-db*])</code>
</dd>
</dl>
<p>Commit the current transaction on the database <code>db-name</code>.</p>
<h2 id="rollback"><code>rollback</code></h2>
<dl>
<dt>Syntax:</dt>
<dd><code>(rollback [db-name *default-db*])</code>
</dd>
</dl>
<p>Abort the current transaction on the database <code>db-name</code>.</p>
<h1 id="appendix-a-connecting">Appendix A: Connecting</h1>
<h2 id="postgresql">PostgreSQL</h2>
<p><strong>Required:</strong></p>
<dl>
<dt><code>:name</code></dt>
<dd>Database name.
</dd>
<dt><code>:user</code></dt>
<dd>User name.
</dd>
<dt><code>:pass</code></dt>
<dd>User password.
</dd>
</dl>
<p><strong>Optional:</strong></p>
<dl>
<dt><code>:host</code></dt>
<dd>Host that runs the database server. Default: &quot;<code>localhost</code>&quot;.
</dd>
<dt><code>:port</code></dt>
<dd>Port the database server listens on. Default: <code>5432</code>.
</dd>
<dt><code>:ssl</code></dt>
<dd><code>:yes</code> enables secure SSL connections to the server. This might be useful if
</dd>
</dl>
<p>the server is running on a host other than the default. Note that OpenSSL must be installed on both machines. For mpre information, see the <a href="http://www.postgresql.org/docs/9.1/static/ssl-tcp.html">relevant PostgreSQL documentation</a>. Default: <code>:no</code>.</p>
<h2 id="sqlite">SQLite</h2>
<p><strong>Required:</strong></p>
<dl>
<dt><code>:name</code></dt>
<dd>The name of the database. As usual, a value of <code>:memory:</code> will create an in-memory database.
</dd>
</dl>
<h2 id="mysql">MySQL</h2>
<p><strong>Required and Optional</strong>: Same as <a href="#postgresql">PostgreSQL</a>, except for <code>:ssl</code>. The default port number <code>3306</code>.</p>
