#+title: Crane Manual

* Overview

Crane is an ORM for Common Lisp. It's intended to provide a simple,
object-oriented interface to relational databases, and is inspired
by the SQLAlchemy ORM for Python.

** Structure

#+begin_src ditaa :file img/dia.png
                       +-----------+
                       | ORM Layer |
                       +-----+-----+
                             |
                         +---+---+
                         | S-SQL |
                         +---+---+
                             |
                       +-----+-----+
                       |  cl-dbi   |
                       +-----+-----+
                             |
     +-----------+----------++--------+--------------+
     |           |          |         |              |
     v           v          v         v              v
+----------+ +--------+ +-------+ +--------+ +---------------+
|      {s} | |    {s} | |   {s} | |    {s} | |           {s} |
| Postgres | | SQLite | | MySQL | | Oracle | | MS SQL Server |
+----------+ +--------+ +-------+ +--------+ +---------------+
#+end_src

Crane mainly uses three libraries:

- [[http://marijnhaverbeke.nl/postmodern/s-sql.html][S-SQL]] :: A DSL for safely generating SQL. Originally created for the
           Postmodern project, an ORM for the PostgreSQL RDBMS.
- [[https://github.com/fukamachi/cl-dbi][CL-DBI]] :: A backend-independent interface to relational DBMSs. At
            present, only PostgreSQL, SQLite version 3, and MySQL are
            supported, but support for Oracle and MS SQL Server
            can be added.
- [[https://github.com/fukamachi/envy][Envy]] :: A configuration manager.

* Tables

Crane uses the metaobject protocol to bind SQL tables and CLOS objects.

SQL tables belong to the =TABLE-CLASS= metaclass, and can be defined as follows:

#+begin_src lisp
  (defclass [name] ([super]*)
    ([field]*)
    (:abstractp {t|nil}))
#+end_src

For example:

#+begin_src lisp
  (crane:defclass enemy ()
    ((name :col-type 'string
           :col-pk t)
     (age :col-type 'integer
          :col-check '(:> 'age 12))
     (address :col-type 'string
              :col-null-p t
              :col-foreign '(important-addresses :cascade :cascade))
     (fatal-weakness
              :col-type 'text
              :col-default "None")
     (identifying-color
              :col-type '(string 20)
              :col-unique t
              :foreign '(colors name)))
    (:metaclass crane:table-class))
#+end_src

** The =deftable= macro

Crane provides a simpler way to define tables through its =deftable=
macro:

#+begin_src lisp
  (deftable [name] ([super]*)
    [field-or-option]*)
#+end_src

Compare the following code to the previous example:

#+begin_src lisp
  (deftable enemy ()
    (name :type string :pk t)
    (age :type integer :check '(:> 'age 12))
    (address :type 'string :nullp t :foreign (important-addresses :cascade :cascade))
    (fatal-weakness :type text :default "None")
    (identifying-color 'type (string 20) :unique t :foreign (colors name)))
#+end_src

* Migrations

Your schema will change, and this is a fact. Most ORMs hope the users
will be happy running manual =ALTER TABLEs= or provide migration functionality
through an external plugin ([[https://alembic.readthedocs.org/en/latest/front.html][Alembic]] for SQLAlchemy, [[http://south.aeracode.org/][South]] for the Django ORM).

Migrations are completely built into Crane, and are designed to be intrusive:
You redefine the schema, reload, and Crane takes care of everything. If your
migration plan is too complicated for Crane, then you write a simple function
that does some transformations and Crane puts that in its migration history,
all that without ever having to leave your Lisp environment or accessing the
shell.

** Example

#+begin_src lisp
  (deftable employees
    (name :type string :null nil)
    (age  :type integer)
    (address :type string :null nil))
#+end_src

Now, if you decide that addresses can be nullable, you just redefine
the class (Make the change, and either =C-c C-c= on Emacs or Quickload
your project):

#+begin_src lisp
  (deftable employees
    (name :type string :null nil)
    (age  :type integer)
    (address :type string))
#+end_src

And Crane will spot the difference and perform the migration automatically.

** Trivial Migrations

Things like adding and dropping contraints (Making a field =NOT NULLable=,
dropping the default value of a column, et cetera) will be handled automatically
by Crane.

A less-than-trivial migration is changing the type of a column: In simple cases,
like moving from a float to an integer, Crane will handle this change automatically.

** Manual Migrations

More complex cases of changing a column's type can't be handled automatically
because of the ambiguity in what the user may be trying to achieve. For example,
changing a column's type from a string to an integer could involve a simple
=PARSE-STRING=, but maybe the user wants to do something more complex. When
Crane can't handle a migration automatically, a migration plan has to be written.

Note: A migration is a set of reversible transformations that take place at a
particular point in the database's history. A migration plan is a blueprint for
a migration, and is not tied to the migration history. Migration plans can be
applied repeatedly to create many migrations.
