#+title: Crane Manual
#+author: Fernando Borretti

* Overview
  
Crane is an ORM for Common Lisp. It's intended to provide a simple,
object-oriented interface to relational databases, and is inspired
by the SQLAlchemy ORM for Python.

** Structure

#+begin_src ditaa :file img/dia.png
Application:

   +--------+       +-------------------+
   | Tables +<--+-->+ Migration History |
   +--------+   |   | {d}               |
                |   +-------------------+
                \------------\
.............................|.........................
                             |
                       +-----+-----+
                       | ORM Layer |
                       +-----+-----+
                             |
                          +--+---+
                          | sxql |
                          +--+---+
                             |
                       +-----+-----+
                       |  cl-dbi   |
                       +-----+-----+
                             |
     +-----------+----------++--------+--------------+
     |           |          |         |              |
     v           v          v         v              v
+----------+ +--------+ +-------+ +--------+ +---------------+
|      {s} | |    {s} | |   {s} | |    {s} | |           {s} |
| Postgres | | SQLite | | MySQL | | Oracle | | MS SQL Server |
+----------+ +--------+ +-------+ +--------+ +---------------+
#+end_src

Crane mainly uses two libraries:

- [[https://github.com/fukamachi/sxql][sxql]] :: A DSL for safely generating SQL.
- [[https://github.com/fukamachi/cl-dbi][CL-DBI]] :: A backend-independent interface to relational DBMSs. At
            present, only PostgreSQL, SQLite version 3, and MySQL are
            supported, but support for Oracle and MS SQL Server
            can be added.
     
* Connecting

Crane autoconnects to all the databases specified in the =:databases= key of the
configuration when the =crane:connect= function is called (No parameters).

Configuration for the databases might look like this:

#+begin_src lisp
#+include: "../t/config.lisp" :lines "3-16"
#+end_src

The value of =:databases= is a plist that maps a database's name (Not that
actual name, but rather a way to identify it, like =:main= or =:users-db=) to a
list of connection parameters, called the /connection spec/.

Crane maintains a list of connection specs for every supported database backend,
and ensures that all required parameters and no parameters other than the
required and optional ones are passed. Connection specs for all supported
backends are listed in [[Appendix A: Connecting][Appendix A]].

* Tables

Crane uses the metaobject protocol to bind SQL tables and CLOS objects through a
=TABLE-CLASS= metaclass. Table classes can be defined simply through the
=deftable= macro:

#+begin_src lisp
  (deftable [name] ([super]*)
    [field-or-option]*)
#+end_src

Compare the following code to the previous example:

#+begin_src lisp
  (deftable enemy ()
    (name :type string :pk t)
    (age :type integer :check '(:> 'age 12))
    (address :type 'string :nullp t :foreign (important-addresses :cascade :cascade))
    (fatal-weakness :type text :default "None")
    (identifying-color 'type (string 20) :unique t :foreign (colors name)))
#+end_src


** Internals

When a table is created, its digest is separated into two parts: Columns, and
constraints. Columns are basically a map of slot names to SQL types. Constraints
are automatically-named SQL constraints created by extracting slot options. That
is, no constraints from the =deftable= macro are nameless, they are all named
and at the column level.

Consider the following table:

#+begin_src lisp
  (deftable user
    (name :type string :pk t :nullp nil)
    (age :type integer :nullp nil))
#+end_src

A human would write SQL like the following:

#+begin_src sql
  CREATE TABLE user (
    name STRING NOT NULL PRIMARY KEY,
    age INTEGER NOT NULL
  )
#+end_src

Crane, however, would generate the following SQL:

#+begin_src sql
  CREATE TABLE user (
    name STRING CONSTRAINT user_name_nullity NOT NULL
                CONSTRAINT user_name_primary PRIMARY KEY,
    age INTEGER CONSTRAINT user_age_nullity NOT NULL
  )
#+end_src

Naming all constraints makes it possible for them to be dropped simply through
=ALTER TABLE= statements when migrating from an old schema.

* Migrations

Your schema will change, and this is a fact. Most ORMs hope the users
will be happy running manual =ALTER TABLEs= or provide migration functionality
through an external plugin ([[https://alembic.readthedocs.org/en/latest/front.html][Alembic]] for SQLAlchemy, [[http://south.aeracode.org/][South]] for the Django ORM).

Migrations are completely built into Crane, and are designed to be intrusive:
You redefine the schema, reload, and Crane takes care of everything. If your
migration plan is too complicated for Crane, then you write a simple function
that does some transformations and Crane puts that in its migration history,
all that without ever having to leave your Lisp environment or accessing the
shell.

** Example

#+begin_src lisp
  (deftable employees
    (name :type string :null nil)
    (age  :type integer)
    (address :type string :null nil))
#+end_src

Now, if you decide that addresses can be nullable, you just redefine
the class (Make the change, and either =C-c C-c= on Emacs or Quickload
your project):

#+begin_src lisp
  (deftable employees
    (name :type string :null nil)
    (age  :type integer)
    (address :type string))
#+end_src

And Crane will spot the difference and perform the migration automatically.

** Trivial Migrations

Things like adding and dropping contraints (Making a field =NOT NULLable=,
dropping the default value of a column, et cetera) will be handled automatically
by Crane.

A less-than-trivial migration is changing the type of a column: In simple cases,
like moving from a float to an integer, Crane will handle this change automatically.
rest
** Manual Migrations

More complex cases of changing a column's type can't be handled automatically
because of the ambiguity in what the user may be trying to achieve. For example,
changing a column's type from a string to an integer could involve a simple
=PARSE-STRING=, but maybe the user wants to do something more complex. When
Crane can't handle a migration automatically, a migration plan has to be written.

Note: A migration is a set of reversible transformations that take place at a
particular point in the database's history. A migration plan is a blueprint for
a migration, and is not tied to the migration history. Migration plans can be
applied repeatedly to create many migrations.

* Creating, Saving, and Deleting Objects

** =create=

*Syntax*: =(create [class] &rest [parameters])=

Create an instance of a class on the database.

*Examples:*

#+begin_src lisp
  (create 'user :name "Eudoxia")

  (create 'company :name "Initech" :founded 1994)
#+end_src

** =save=

*Syntax*: =(save [instance])=

Save an instance's fields to the database.

*Examples:*

#+begin_src lisp
  (let ((point (create 'point :x 556.3 :y 26.7)))
    ;; Make some changes
    (setf (point-distance-from-origin point)
          (euclidean-distance point '(0 0)))
    ;; Save
    (save point))
#+end_src

** =del=

*Syntax*: =(del [instance])=

Delete an instance from the database.

*Examples:*

#+begin_src lisp
  (defun delete-user (username)
    (del (single 'user :name username)))
#+end_src

* Making Queries

** High Level API

*** =filter=

*Syntax*: =(filter [class] &rest [params])=

Return a list of objects that satisfy the =params=.

*Examples:*

#+begin_src lisp
  (filter 'company :country "US"
                   (:< nemployees 40))
#+end_src

*** =single=

*Syntax*: =(filter [class] &rest [params])=

Return a singel object that satisfies the parameters.

A variant, =single!=, will signal a condition when no object satisfies the
parameters.

*** =get-or-create=

** Functional SQL



* Appendix A: Connecting

** PostgreSQL

Required:
- =:name= :: Database name.
- =:user= :: User name.
- =:pass= :: User password.

Optional:
- =:host= :: Host that runs the database server. Default: "=localhost=".
- =:port= :: Port the database server listens on. Default: =5432=.
- =:ssl= :: =:yes= enables secure SSL connections to the server. This might be
            useful if the server is running on a host other than the
            default. Note that OpenSSL must be installed on both machines. For
            more information, see the [[http://www.postgresql.org/docs/9.1/static/ssl-tcp.html][relevant PostgreSQL
            documentation]]. Default: =:no=.

** SQLite

Required:
- =:name= :: The name of the database. As usual, a value of "=:memory:=" will
             create an in-memory database.

** MySQL

Required and Optional: Same as [[PostgreSQL]], except for =:ssl=. The default port
number =3306=.
